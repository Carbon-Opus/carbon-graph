type Token @entity(immutable: false) {
  id: ID! # token address
  creator: Creator!
  name: String!
  symbol: String!
  createdAt: BigInt!
  creatorAllocation: BigInt!
  graduated: Boolean!
  graduatedAt: BigInt
  liquidityTokens: BigInt
  liquidityUsdc: BigInt
  virtualUsdc: BigInt!
  virtualTokens: BigInt!
  maxSupply: BigInt!
  graduationThreshold: BigInt!
  realUsdcReserves: BigInt!
  realTokenSupply: BigInt!
  price: BigInt!
  totalHolders: BigInt!
  holders: [Holder!]! @derivedFrom(field: "token")
  transactions: [Transaction!]! @derivedFrom(field: "token")
  approvals: [Approval!]! @derivedFrom(field: "token")
  whaleIntents: [WhaleIntent!]! @derivedFrom(field: "token")
  bots: [BotDetection!]! @derivedFrom(field: "token")
  protectionEvents: [ProtectionEvent!]! @derivedFrom(field: "token")
  isCircuitBreakerActive: Boolean!
  circuitBreakerTriggeredAt: BigInt
  circuitBreakerDuration: BigInt
  isPaused: Boolean!
  isTradingPaused: Boolean!
  lastPriceUpdate: BigInt!
  volatilityMoveCount: BigInt!
  emergencyWithdrawals: [EmergencyWithdrawal!]! @derivedFrom(field: "token")

  # DEX Graduation fields
  "DEX pair entity (null if not graduated)"
  dexPair: DexPair

  "DEX pair address (for quick queries)"
  dexPairAddress: Bytes

  "Whether liquidity has been deployed to DEX"
  liquidityDeployed: Boolean!

  "Transaction hash of liquidity deployment"
  liquidityDeploymentTx: Bytes
}

type Creator @entity(immutable: false) {
  id: ID! # creator address
  tokens: [Token!]! @derivedFrom(field: "creator")
  createdAt: BigInt!
  totalFeesCollected: BigInt!
}

type User @entity(immutable: false) {
  id: ID! # user address
  tokens: [Holder!]! @derivedFrom(field: "user")
  approvals: [Approval!]! @derivedFrom(field: "owner")
  whaleIntents: [WhaleIntent!]! @derivedFrom(field: "trader")
  blacklisted: [BlacklistEvent!]! @derivedFrom(field: "user")
  whitelisted: [WhitelistEvent!]! @derivedFrom(field: "user")
  bots: [BotDetection!]! @derivedFrom(field: "user")
}

type Holder @entity(immutable: false) {
  id: ID! # user address + token address
  user: User!
  token: Token!
  balance: BigInt!
}

type Transaction @entity(immutable: true) {
  id: ID! # transaction hash + log index
  token: Token!
  tokenId: ID!
  type: String! # "buy" or "sell"
  trader: Bytes! # address of the buyer/seller
  usdcAmount: BigInt!
  tokenAmount: BigInt!
  price: BigInt!
  realUsdcReserves: BigInt!
  realTokenSupply: BigInt!
  timestamp: BigInt!
}

type Approval @entity(immutable: true) {
  id: ID! # transaction hash + log index
  token: Token!
  owner: User!
  spender: Bytes!
  value: BigInt!
  timestamp: BigInt!
}

type WhaleIntent @entity(immutable: false) {
  id: ID! # token address + trader address
  token: Token!
  trader: User!
  amount: BigInt!
  isBuy: Boolean!
  executeAfter: BigInt!
  timestamp: BigInt!
  cancelled: Boolean!
  executed: Boolean!
}

type BotDetection @entity(immutable: true) {
  id: ID! # transaction hash + log index
  token: Token!
  user: User!
  reason: String!
  timestamp: BigInt!
}

type BlacklistEvent @entity(immutable: true) {
  id: ID! # transaction hash + log index
  token: Token!
  user: User!
  blacklisted: Boolean!
  timestamp: BigInt!
}

type WhitelistEvent @entity(immutable: true) {
  id: ID! # transaction hash + log index
  token: Token!
  user: User!
  whitelisted: Boolean!
  timestamp: BigInt!
}

type ProtectionEvent @entity(immutable: true) {
  id: ID! # transaction hash + log index
  token: Token!
  eventType: String! # "CircuitBreakerTriggered", "CircuitBreakerReset", "VolatilityWarning", "HighPriceImpact"
  reason: String
  trader: Bytes
  impact: BigInt
  moveCount: BigInt
  duration: BigInt
  timestamp: BigInt!
}

type EmergencyWithdrawal @entity(immutable: true) {
  id: ID! # transaction hash + log index
  token: Token!
  to: Bytes!
  amount: BigInt!
  timestamp: BigInt!
}

type Song @entity(immutable: false) {
  id: ID! # tokenID
  artist: Artist!
  price: BigInt!
  referralPct: BigInt!
  createdAt: BigInt!
  purchases: [SongPurchase!]! @derivedFrom(field: "song")
}

type Artist @entity(immutable: false) {
  id: Bytes! # memberId
  address: Bytes!
  songs: [Song!]! @derivedFrom(field: "artist")
  rewards: BigInt!
  claimedRewards: [Reward!]! @derivedFrom(field: "artist")
}

type Buyer @entity(immutable: false) {
  id: Bytes! # memberId
  address: Bytes!
  purchases: [SongPurchase!]! @derivedFrom(field: "buyer")
}

type Referrer @entity(immutable: false) {
  id: Bytes! # memberId
  address: Bytes!
  referrals: [SongPurchase!]! @derivedFrom(field: "referrer")
  rewards: BigInt!
  claimedRewards: [Reward!]! @derivedFrom(field: "referrer")
}

type SongPurchase @entity(immutable: true) {
  id: ID! # transaction hash + log index
  song: Song!
  buyer: Buyer!
  referrer: Referrer
  price: BigInt!
  timestamp: BigInt!
}

type Reward @entity(immutable: true) {
  id: ID! # transaction hash + log index
  artist: Artist
  referrer: Referrer
  amount: BigInt!
  timestamp: BigInt!
}

type Protocol @entity(immutable: false) {
  id: ID!
  totalRewardsClaimed: BigInt!
  totalRewardsDistributed: BigInt!
  protocolFee: BigInt!
  owner: Bytes!
  controller: Bytes!
}

type Launcher @entity(immutable: false) {
  id: ID! # Always "1"
  owner: Bytes!
  controller: Bytes!
  maxTokensPerCreator: BigInt!
  paused: Boolean!
  totalFeesCollected: BigInt!
  totalTokensCreated: BigInt!
  feeReceipts: [FeeReceipt!]! @derivedFrom(field: "launcher")
  feeWithdrawals: [FeeWithdrawal!]! @derivedFrom(field: "launcher")
}

type FeeReceipt @entity(immutable: true) {
  id: ID! # transaction hash + log index
  launcher: Launcher!
  from: Bytes!
  amount: BigInt!
  timestamp: BigInt!
}

type FeeWithdrawal @entity(immutable: true) {
  id: ID! # transaction hash + log index
  launcher: Launcher!
  to: Bytes!
  amount: BigInt!
  timestamp: BigInt!
}

type ConfigUpdate @entity(immutable: true) {
  id: ID! # transaction hash + log index
  configType: String! # "DefaultConfig"
  timestamp: BigInt!
}

type DexPair @entity(immutable: false) {
  "DEX pair address"
  id: ID!

  "The token that graduated"
  token: Token!

  "Creator of the token"
  creator: Bytes!

  "DEX pair contract address"
  pairAddress: Bytes!

  "Amount of tokens added to liquidity"
  tokenAmount: BigInt!

  "Amount of USDC added to liquidity"
  usdcAmount: BigInt!

  "Amount of LP tokens minted"
  liquidityTokens: BigInt!

  "Timestamp of deployment"
  deployedAt: BigInt!

  "Transaction hash"
  deploymentTx: Bytes!
}

type Dex @entity(immutable: false) {
  "Singleton entity (id: '1')"
  id: ID!

  "Total number of pairs deployed"
  totalPairs: BigInt!

  "Total USDC value locked in graduated pairs"
  totalUsdcLocked: BigInt!

  "Total token value locked in graduated pairs"
  totalTokensLocked: BigInt!

  "Is DEX paused"
  paused: Boolean!

  "Config address"
  config: Bytes!
}

type DexPauseEvent @entity(immutable: true) {
  id: ID!
  dex: Dex!
  paused: Boolean!
  timestamp: BigInt!
}

type DexConfigUpdate @entity(immutable: true) {
  id: ID!
  dex: Dex!
  oldConfig: Bytes!
  newConfig: Bytes!
  timestamp: BigInt!
}